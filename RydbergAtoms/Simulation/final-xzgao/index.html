<!doctype html> <html lang=en  class=h-100> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width,initial-scale=1,shrink-to-fit=no"> <meta content="index, follow" name=robots> <link rel=icon  href="/trainingcamp/assets/favicon.ico"> <link rel=alternate  type="application/rss+xml" href="/trainingcamp/post/index.xml" title="RSS Feed for JuliaGPU"> <link rel=stylesheet  href="/trainingcamp/css/bootstrap.min.css"> <link rel=stylesheet  href="/trainingcamp/libs/katex/katex.min.css"> <link rel=stylesheet  href="/trainingcamp/libs/highlight/github.min.css"> <style> .hljs { padding: 0; background: 0 0 } .container { max-width: 700px } #nav-border { border-bottom: 1px solid #212529 } #main { margin-top: 1em; margin-bottom: 4em } #home-jumbotron { background-color: inherit } #footer .container { padding: 1em 0 } #footer a { color: inherit; text-decoration: underline } .font-125 { font-size: 125% } .tag-btn { margin-bottom: .3em } pre { background-color: #f5f5f5; border: 1px solid #ccc; border-radius: 4px; padding: 16px } pre code { padding: 0; font-size: inherit; color: inherit; background-color: transparent; border-radius: 0 } code { padding: 2px 4px; font-size: 90%; color: #c7254e; background-color: #f9f2f4; border-radius: 4px } img, iframe, embed, video, audio { max-width: 100% } .card-img, .card-img-top, .card-img-bottom { width: initial } #main h1>a, #main h2>a, #main h3>a { color: inherit; text-decoration: none; } li p { margin: 0 } </style> <title>Tensor-Based Simulation Methods for Quantum Many Body Systems ⋅ Numeric Gangster</title> <body class="d-flex flex-column h-100"> <div id=nav-border class=container> <nav class="navbar navbar-expand-lg navbar-light justify-content-center"> <ul class=navbar-nav> <li class="nav-item "><a class=nav-link href="/trainingcamp/"><i data-feather=home></i>Home</a> <li class="nav-item "><a class=nav-link href="/trainingcamp/RydbergAtoms/"><i data-feather=file-text></i>Rydberg Atoms</a> <!-- <li class="nav-item {{ispage learn}}active{{end}}"><a class=nav-link href="/trainingcamp/Correction/">Quantum Error Correction</a> <li class="nav-item {{ispage cuda}}active{{end}}"><a class=nav-link href="/trainingcamp/Algorithms/">Algorithm</a> <li class="nav-item {{ispage rocm}}active{{end}}"><a class=nav-link href="/trainingcamp/Simulations/">Simulations</a> --> </ul> </nav> </div> <div class=container > <main id=main> <h2 id=tensor-based_simulation_methods_for_quantum_many_body_systems ><a href="#tensor-based_simulation_methods_for_quantum_many_body_systems" class=header-anchor >Tensor-Based Simulation Methods for Quantum Many Body Systems</a></h2> <p>In this section, we will introduce some of the basic simulation methods for quantum many body systems, based on tensor network contractions. We will start by introducing the basic concepts of tensor networks, and then we will show how can that combine with Quantum many body systems, by introducing the Matrix Product States &#40;MPS&#41; <sup id="fnref:MPS"><a href="#fndef:MPS" class=fnref >[1]</a></sup> and Matrix Product Operations &#40;MPO&#41; <sup id="fnref:MPO"><a href="#fndef:MPO" class=fnref >[2]</a></sup>. Further, two important algorithms for simulating quantum many body systems will be introduced, including the Density Matrix Renormalization Group &#40;DMRG&#41; <sup id="fnref:DMRG"><a href="#fndef:DMRG" class=fnref >[3]</a></sup> <sup id="fnref:Schollwöck"><a href="#fndef:Schollwöck" class=fnref >[4]</a></sup> and the Time Dependent Variational Principle &#40;TDVP&#41; <sup id="fnref:TDVP"><a href="#fndef:TDVP" class=fnref >[5]</a></sup> <sup id="fnref:Verstraete"><a href="#fndef:Verstraete" class=fnref >[6]</a></sup>, which are used to search for the ground state and simulate the time evolution of quantum many body systems, respectively. As an end, a simple implementation based on <code>OMEinsum.jl</code> of these algorithms will be shown.</p> <h3 id=tensors_and_tensor_networks ><a href="#tensors_and_tensor_networks" class=header-anchor >Tensors and Tensor Networks</a></h3> <p>In the recent few decades, tensor networks &#40;TNs&#41; as a powerful tool have been widely used in various fields, include machine learning, quantum many body systems, and quantum information theory, etc, due to its ability to represent high-dimensional data and efficiently compute the contraction of high-dimensional tensors.</p> <p>The basic elements of tensor networks are tensors, which are a multi-dimensional arrays. A tensor \(A\) with rank \(d\) can be represented as \(A_{i_1, i_2, \cdots, i_d}\), where \(i_1, i_2, \cdots, i_d\) are the indices of the tensor \(A\). For example, a scalar is a rank zero tensor and a vector/matrix can be represented as a tensor with rank 1/2, respectively. As shown in the following figure, we can represent the tensor \(A\) as a circle with \(d\) legs, where each leg corresponds to an index of the tensor.</p> <p><img src="figs/tensors.svg" alt="" /></p> <p>Then by connecting the legs with shared indices of the tensors, we get a tensor network, so that we will be able to define the contraction on the tensor network, which is to sum over all the shared indices of the tensors, and the result is a new tensor. A simple example is given in the following figure.</p> <p><img src="figs/tensor_network.svg" alt="" /></p> <p>This contraction represents the multiplication of two matrices \(A\) and \(B\), and the result is a new matrix \(C\), i.e.,</p> \[ C_{i, j} = \sum_{k} A_{i, k} B_{k, j} \;. \] <h3 id=matrix_product_states_mps ><a href="#matrix_product_states_mps" class=header-anchor >Matrix Product States &#40;MPS&#41;</a></h3> <p>Matrix Product States &#40;MPS&#41; is a special form of tensor network, which is widely used to represent the wave function of 1D quantum many body systems. Consider a 1D chain with \(N\) sites, and each site has a local Hilbert space with dimension \(d\). Then to fully describe the quantum state of the system, we need a tensor with rank \(N\), i.e., a tensor with \(N\) legs and have a space complexity of \(d^N\), and can be represented as:</p> <p><img src="figs/full_phi.svg" alt="" /></p> <p>which indicates that the space complexity of the tensor is exponential with respect to the system size, which is not practical for large systems. Another way to represent the wave function is by a set of connect tensors, i.e., a tensor network, as shown in the following figure:</p> <p><img src="figs/mps.svg" alt="" /></p> <p>where the black circles represent the high dimensional matrices, the red lines represent the physical indices with dims \(d\), and the black lines represent the bond indices with dims \(D\). It is clear that if want to represent the wave function exactly, we still need exponential large bond dimensions. However, in many cases we are interested in, the entanglement of the quantum many body systems is limited, and it has been shown that in such cases the bond dimension can be a finite constant, which means that the quantum state of the system can be well approximated by a set low-rank tensors. The total space complexity of the MPS is \(O(d D^2 N)\), which is linear to the system&#39;s size.</p> <p>According to the low rank nature, we can reduce the large high-dims tensor to a MPS. For example, if we have a 3 order tensor \(T_{ijk}\), we can first merge two of the indices to form a matrix \(M_{i,jk}\), and then apply the SVD to the matrix, so that</p> <pre><code class=language-math >M_&#123;i, jk&#125; &#61; U_&#123;i,l&#125; S_&#123;l&#125; V_&#123;l, jk&#125;^&#123;\dagger&#125; &#61; U_&#123;i,l&#125; R_&#123;l, jk&#125;,</code></pre>
<p>so that the original huge tensor is split into two connected smaller tensors \(U_{i,l}\) and \(R_{l, jk}\). Repeat this process, a large tensor can be represented as a product of smaller tensors, which is the MPS representation of the original tensor.</p>
<p><img src="figs/tensor2mps.png" alt="" /></p>
<p>Furthermore, according to the SVD, we have </p>
<pre><code class=language-math >U^&#123;\dagger&#125; U &#61; I, V^&#123;\dagger&#125; V &#61; I.</code></pre>
<p>In this case, we will have two different gauge choices, by choosing \(U\) or \(V\) as the site tensors. The corresponding MPS representation are called <strong>left-canonical</strong> and <strong>right-canonical</strong> MPS, and of-cause you can have mixed-canonical MPS.</p>
<h3 id=matrix_product_operators_mpo ><a href="#matrix_product_operators_mpo" class=header-anchor >Matrix Product Operators &#40;MPO&#41;</a></h3>
<p>Similar to the MPS, the Matrix Product Operators &#40;MPO&#41; is a tensor network representation of a quantum operator. As introduced above, for a \(N\) sites 1D string, a quantum operator is represented by a tensor with rank \(2N\), which has a space complexity of \(d^{2N}\), which is even larger than the MPS representation of the quantum state. Fortunately, most of the operations are local, and can be represented as a product of local tensors. One way to represent such a product is by a Matrix Product Operators &#40;MPO&#41;, as shown in the following figure: <img src="https://tensornetwork.org/mpo/mpo.png" alt="" /> which can be applied on a MPS.</p>
<h3 id=density_matrix_renormalization_group_dmrg ><a href="#density_matrix_renormalization_group_dmrg" class=header-anchor >Density Matrix Renormalization Group &#40;DMRG&#41;</a></h3>
<p>Density Matrix Renormalization Group &#40;DMRG&#41; is a numerical method to find the ground state of a quantum many body system. The basic idea of DMRG is to find the ground state of a quantum many body system by iteratively optimizing the MPS representation of the quantum state. The optimization is done by minimizing the energy of the system, which is represented as a function of the MPS tensors. The optimization is done by a variational principle, and the energy is minimized by a set of linear equations, which can be solved by a set of linear algebra methods, such as the Lanczos algorithm.</p>
<p>Generally, the Hamiltonian of a quantum many body system can be represented as a tensor: <img src="https://tensornetwork.org/mps/algorithms/dmrg/H_diagram.png" alt="" /> so that the group state problem can be represented as find the lowest eigenvalue of this linear equation: <img src="https://tensornetwork.org/mps/algorithms/dmrg/H_eigenvector.png" alt="" /> Then by representing the Hamiltonian as a MPO, <img src="https://tensornetwork.org/mps/algorithms/dmrg/H_MPO_form.png" alt="" /> we can start an iterative optimization process.</p>
<p>Generally speaking, in each step, the Hamiltonian is projected onto the subspace spanned by two neighboring sites, and then we can use the Lanczos algorithm to find the ground state of the projected Hamiltonian and optimize part of the MPS.</p>
<p>In the beginning, the process starts with a random MPS, and we first optimize the first two sites. Then projection Hamiltonian is represented as <img src="https://tensornetwork.org/mps/algorithms/dmrg/projected_H.png" alt="" /> and the projected quantum state is represented as <img src="https://tensornetwork.org/mps/algorithms/dmrg/bond1.png" alt="" /> so that we can use Lanczos algorithm or other method to find the ground state in the project subspace.</p>
<p>In next step, we apply SVD to the optimized \(B_{12}\) as <img src="https://tensornetwork.org/mps/algorithms/dmrg/B12_svd.png" alt="" /> and merge the diagonal matrix into the next site tensor <img src="https://tensornetwork.org/mps/algorithms/dmrg/SV_mult.png" alt="" /> so that we can optimize the next two sites. Each step of this process can be represented as <img src="https://tensornetwork.org/mps/algorithms/dmrg/summary_opt.png" alt="" /> In this way, finally we will get the ground state of the quantum many body system.</p>
<h3 id=time_dependent_variational_principle_tdvp ><a href="#time_dependent_variational_principle_tdvp" class=header-anchor >Time Dependent Variational Principle &#40;TDVP&#41;</a></h3>
<p>DMRG is a efficient method to find the ground state of a quantum many body system, however, it is not suitable for simulating the time evolution of a quantum many body system. For this purpose, the Time Dependent Variational Principle &#40;TDVP&#41; is proposed to simulate the time evolution.</p>
<p>Time evolution of a quantum state is governed by the Schrödinger equation:</p>
\[
\frac{d}{dt} |\psi(t)\rangle = - i \hbar H |\psi(t)\rangle,
\]
<p>which is a first order differential equation, and can be solved by a set of numerical methods, such as the Runge-Kutta method, etc. However, for a quantum many body system, the dimension of the Hilbert space is exponential with respect to the system size, and it is not practical to solve the Schrödinger equation directly.</p>
<p>The basic idea of TDVP is to simulate the time evolution of a quantum many body system by optimizing the MPS representation of the quantum state. The optimization is done by minimizing the distance between the quantum state at time \(t\) and the quantum state at time \(t + \delta t\), which is represented as a function of the MPS tensors. The optimization is done by a variational principle, and the distance is minimized by a set of linear equations, which are almost the same as the DMRG algorithm.</p>
<p>Here we will introduce the simple case, where we update only one site of the MPS, \(A\), in each iteration, and the time evolution operator:</p>
\[
\frac{d}{dt} |\psi(A)\rangle = - i \hat{P}_{T(A)} H |\psi(t)\rangle,
\]
<p>where \(\hat{P}\) is the tangent space projector, and \(T(A)\) is the tangent space of the MPS at site \(A\), and the projector can be given by</p>
\[
\hat{P}_{T} = \sum_{j = 1}^N P^{L}_{j - 1} \otimes \hat{1}_j \otimes P^{R}_{j + 1} - \sum_{j = 1}^{N - 1} P^{L}_{j} \otimes P^{R}_{j + 1},
\]
<p>In language of MPS, the left or right projector can be represented as <img src="https://tensornetwork.org/mps/algorithms/timeevo/tdvp_projectors.svg" alt="" /> which is the same as that of the DMRG algorithm.</p>
<p>Then projected states are represented as <img src="https://tensornetwork.org/mps/algorithms/timeevo/tdvp_efftdse.svg" alt="" /> and <img src="https://tensornetwork.org/mps/algorithms/timeevo/tdvp_efftdse_bond.svg" alt="" /> corresponding to the first and the second term of the projector.</p>
<p>Then in TDVP, we apply these two terms iteratively to get the projected Hamiltonian and the projected quantum state, and then we can evolve the quantum state to the next time step.</p>
<h3 id=references ><a href="#references" class=header-anchor >References</a></h3>
<p><table class=fndef  id="fndef:MPS">
    <tr>
        <td class=fndef-backref ><a href="#fnref:MPS">[1]</a>
        <td class=fndef-content >https://tensornetwork.org/mps/index.html#component
    
</table>
 <table class=fndef  id="fndef:MPO">
    <tr>
        <td class=fndef-backref ><a href="#fnref:MPO">[2]</a>
        <td class=fndef-content >https://tensornetwork.org/mpo/
    
</table>
 <table class=fndef  id="fndef:DMRG">
    <tr>
        <td class=fndef-backref ><a href="#fnref:DMRG">[3]</a>
        <td class=fndef-content >https://tensornetwork.org/mps/algorithms/dmrg/
    
</table>
 <table class=fndef  id="fndef:TDVP">
    <tr>
        <td class=fndef-backref ><a href="#fnref:TDVP">[5]</a>
        <td class=fndef-content >https://tensornetwork.org/mps/algorithms/timeevo/tdvp.html
    
</table>
 <table class=fndef  id="fndef:Schollwöck">
    <tr>
        <td class=fndef-backref ><a href="#fnref:Schollwöck">[4]</a>
        <td class=fndef-content >U. Schollwöck, The density-matrix renormalization group in the age of matrix product states, Annals of Physics 326, 96-192 &#40;2011&#41;
    
</table>
 <table class=fndef  id="fndef:Verstraete">
    <tr>
        <td class=fndef-backref ><a href="#fnref:Verstraete">[6]</a>
        <td class=fndef-content >Verstraete, F., Nishino, T., Schollwöck, U. et al. Density matrix renormalization group, 30 years on. Nat Rev Phys 5, 273–276 &#40;2023&#41;. https://doi.org/10.1038/s42254-023-00572-5
    
</table>
</p>

      </main>
    </div> 


    
        <script src="/trainingcamp/libs/katex/katex.min.js"></script>
<script src="/trainingcamp/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        <script src="/trainingcamp/libs/highlight/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    

    <footer id=footer class="mt-auto text-center text-muted">
        <div class=container>Made with <a href=https://franklinjl.org>Franklin.jl</a> and <a href=https://julialang.org>the Julia programming language</a>.</div>
    </footer>

    
    <script src="/trainingcamp/libs/feather/feather.min.js"></script>
    <script>feather.replace()</script>

    
    <script>
    window.ga = window.ga || function() {
        (ga.q = ga.q || []).push(arguments)
    };
    ga.l = +new Date;
    ga('create', 'UA-154489943-1', 'auto');
    ga('send', 'pageview');
    </script>
    <script async src=https://www.google-analytics.com/analytics.js></script>