<!doctype html>
<html lang="en" class=h-100>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no">
  <meta content="index, follow" name=robots>
  <link rel="icon" href="/assets/logo_crop.png">
  <link rel="alternate" type="application/rss+xml" href="/post/index.xml" title="RSS Feed for JuliaGPU">

  <link rel="stylesheet" href="/css/bootstrap.min.css">
   <link rel="stylesheet" href="/libs/katex/katex.min.css">
     
   <link rel="stylesheet" href="/libs/highlight/github.min.css">
 

  <style>
 .hljs {
     padding: 0;
     background: 0 0
 }
.container {
   max-width: 700px
}

#nav-border {
   border-bottom: 1px solid #212529
}

#main {
   margin-top: 1em;
   margin-bottom: 4em
}

#home-jumbotron {
   background-color: inherit
}

#footer .container {
   padding: 1em 0
}

#footer a {
   color: inherit;
   text-decoration: underline
}

.font-125 {
   font-size: 125%
}

.tag-btn {
   margin-bottom: .3em
}

pre {
   background-color: #f5f5f5;
   border: 1px solid #ccc;
   border-radius: 4px;
   padding: 16px
}

pre code {
   padding: 0;
   font-size: inherit;
   color: inherit;
   background-color: transparent;
   border-radius: 0
}

code {
   padding: 2px 4px;
   font-size: 90%;
   color: #c7254e;
   background-color: #f9f2f4;
   border-radius: 4px
}


h1 {
    margin-top: 1em;
}

h2 {
    margin-top: 1em;
}

h3 {
    margin-top: 0.6em;
}
img,
iframe,
embed,
video,
audio {
   max-width: 100%
}

.card-img,
.card-img-top,
.card-img-bottom {
   width: initial
}

#main h1>a, #main h2>a, #main h3>a {
   color: inherit;
   text-decoration: none;
}

li p {
   margin: 0
}

.result-title a { text-decoration: none; }
.result-title a:hover { text-decoration: underline; }
.result-preview { color: #808080; }
.resultCount { color: #808080; }
.result-query { font-weight: bold; }
#lunrSearchForm { margin-top: 1em; }

</style>


  
  
    <title>Quantum Cellular Automata and its implementation ⋅ Quantum Bay</title>
  
</head>
<body class="d-flex flex-column h-100">
  <div id=nav-border class=container>
    <nav class="navbar navbar-expand-lg navbar-light justify-content-center">
        <ul class="navbar-nav">
            <li class="nav-item "><a class="nav-link" href="/"><i data-feather="home"></i>Home</a></li>
            <li class="nav-item "><a class="nav-link" href="/Publications/"><i data-feather="file-text"></i>Publications</a></li>
            <li class="nav-item "><a class="nav-link" href="/Learning/"><i data-feather="book-open"></i>Learning</a></li>
            <li class="nav-item active"><a class="nav-link" href="/Events/"><i data-feather="bell"></i>Events</a></li>
            <li class="nav-item "><a class="nav-link" href="/About/"><i data-feather="help-circle"></i>About</a></li>
        </ul>
    </nav>
</div>


  <div class="container">
    <main id=main>

    
<!-- Content appended here -->
 <!doctype html>
<!-- first few lines ... -->
  <script src="/libs/lunr/lunr.min.js"></script>
  <script src="/libs/lunr/lunr_index.js"></script>
  <script src="/libs/lunr/lunrclient.min.js"></script>
</head>
<!-- ... -->
<form id="lunrSearchForm" name="lunrSearchForm" style="text-align:center; margin-bottom:20px;">
  <input class="search-input" name="q" placeholder="Enter search term" type="text">
  <input type="submit" value="Search" formaction="/search/index.html">
</form>
<h1 id="quantum_cellular_automata_and_its_implementation"><a href="#quantum_cellular_automata_and_its_implementation" class="header-anchor">Quantum Cellular Automata and its implementation</a></h1>
<ul>
<li><p>Qingyun Qian: <a href="mailto:qqian716@connect.hkust-gz.edu.cn">qqian716@connect.hkust-gz.edu.cn</a>,</p>
</li>
<li><p>Yusheng Zhao: <a href="mailto:yzhao053@connect.hkust-gz.edu.cn">yzhao053@connect.hkust-gz.edu.cn</a></p>
</li>
</ul>
<h2 id="1reversible_cellular_automata"><a href="#1reversible_cellular_automata" class="header-anchor">1.Reversible Cellular Automata </a></h2>
<h3>1.1Motivation</h3>
<p>In theoretical computer science, we have three models of computation that are equivalent and universal. The lambda calculus model is the one that best captures the essence of computation. It achieves so by abstracting the process of computation into function calls. And the unimaginable multitude of universal of computation is achieved through calling and nesting of such elementary functions. The partial recursive function model is the one that is closest to how a modern programmer trained with the imperative programming paradigm perceives computation. The Turing machine model being the one that abstracts the way humans do computation. A piece of data is copied onto an information carrying medium and an object is instructed to modify data upon reading some portion of the medium. </p>
<p>Such models have done a great job in rigorously modeling the process of computation. But they are not so helpful in improving the efficiency of computation. The reason is that they are not physical in the sense that they don&#39;t encapsulate the physical evolution of a system. As the Church-Turing thesis states, no known computation model can simulate the evolution of a physical model faster than the physical evolution itself. Therefore, a model that captures the physical evolution of a system can be used to device a more efficient computation model. </p>
<p>Reversible Cellular Automata &#40;RCA&#41; is such a model. It is first and foremost a cellular automata, which is a model of computation that captures the concept of locality, a propoerty found in most physical processes. It is reversible in the sense that it is possible to reverse the evolution of the system. The last point is important since reversible processes don&#39;t increase entropy. By <a href="https://www.cs.princeton.edu/courses/archive/fall06/cos576/papers/bennett03.pdf">Landauer&#39;s principle</a>, all logical computation that decreases entropy must be accompanied with an increase of the entropy in the environment. These entropies must be changed with input energy. Hence the irreversible operations are not energy efficient.</p>
<h3>1.2 Implementation of RCA</h3>
<p>The implementation of Reversible Cellular Automata follows from the paper by Margolus et. al. <sup id="fnref:1"><a href="#fndef:1" class="fnref">[1]</a></sup>.</p>
<p>An RCA is defined by the following components:</p>
<ol>
<li><p>A set of states &#36;S&#36;. In our implementation, we limit it to \(\{1, 2\}\).</p>
</li>
<li><p>A <code>space</code> where the cells are located. And, each cell contains a member of the set \(S\).</p>
</li>
<li><p>A <code>parity</code> variable that records the parity of the space. It is used to determine how to group the cells into inputs of a <code>gate</code>.</p>
</li>
</ol>
<p>At the time of computation, we provide a function <code>f1</code> that determines the output cell state given the input cell states. The function <code>f1</code> is a reversible function. It is a function that can be reversed.</p>
<p>The following mapping with all four rotations of them is an example of such a reversible function.</p>
<p><img src="reversible_rules.png" alt="Reversible" /></p>
<p>This function is applied to different grouping of cells according to the parity of time step of evolution. At odd time step, the cells in each solid line block are groupped together. At even time step, the cells in each wiggling line block are groupped together.</p>
<p><img src="cell_grouping.png" alt="Cell Grouping" /></p>
<p>Since the function <code>f1</code> is reversible, thei computation model is reversible. The only thing remains to be shown is the universality of such model.</p>
<h3 id="13_universality_of_rca"><a href="#13_universality_of_rca" class="header-anchor">1.3 Universality of RCA</a></h3>
<p>The way we show universality of RCA is by first realizing that billiard ball model is universal. And then we show that RCA can simulate billiard ball model.</p>
<p>A billiard ball model is a model of computation that is based on the movement of billiard balls. The trajectory of which the ball moves can be treated as wires. </p>
<p><img src="image.png" alt="alt text" /></p>
<p>There are mirrors that can change the direction of which the ball moves. </p>
<p><img src="image-1.png" alt="alt text" /></p>
<p>They combine to make a gate. As an example, this <a href="https://www.youtube.com/watch?v&#61;7ZEX3yYFUtc&amp;list&#61;PLtIA-JFuqjJV-J5ujaGjTKhiXrqTE_mGZ&amp;index&#61;1">video</a> shows how to make an AND gate using billiard balls.</p>
<p>There are also ways to simulate the <code>OR</code> and <code>NOT</code> gates. Together, the three gates are enough to make a universal computation model. Therefore, the billiard model is universal.</p>
<h3 id="14_conversion_of_billiard_ball_model_to_rca"><a href="#14_conversion_of_billiard_ball_model_to_rca" class="header-anchor">1.4 Conversion of Billiard Ball Model to RCA</a></h3>
<p>It is easy to see that RCA can simulate the movement of a billiard ball. We could treat the <code>1</code> state of the cell as having a ball there. The following evolution following from our previously defined reversible function <code>f1</code> can simulate the movement of the ball. </p>
<p><img src="image-2.png" alt="alt text" /></p>
<p>The mirror of the billiard ball model can be simulated by the following evolution.</p>
<p><img src="image-3.png" alt="alt text" /></p>
<p>Another important feature a RCA model needs to have is the ability to do time delay. It is needed for multiple purposes. Firstly, it allows for easier wiring of the ball trajectories. Two trajectories don&#39;t have to interact even it they corss each other. This can be done with a time delay in the trajectory of two balls. </p>
<p>More importantly, it is needed for adjusting the time delay caused by simulation of the billiard ball collision. The time delay occurs at the third and fourth time step of the evolution. It is needed to adjust the time delay caused by the collision of the billiard balls because at the same time other parts of the cellular automata are simulating the computation with no time delay.</p>
<p><img src="image-5.png" alt="alt text" /></p>
<h3 id="21_quantum_cellular_automata"><a href="#21_quantum_cellular_automata" class="header-anchor">2.1 Quantum Cellular Automata</a></h3>
<p>An early way of implementing Quantum Cellular Automata is designed in <sup id="fnref:2"><a href="#fndef:2" class="fnref">[2]</a></sup>. In this paper, the quantum cellular automata has the following definition:</p>
<ol>
<li><p>Basis States: the possible state in the cell of the automata can be one of the four states: \(\{0, 1, \epsilon\}\) or a solid block. The \(\{0,1\}\) states vaguely represents moving qubits with state \(\ket{0}\) and \(\ket{1}\). The \(\epsilon\) state represents an empty state. THe solid block is an immobile block that cannot be changed and acts like a reflecting wall in the automata. </p>
</li>
<li><p>World: the world where the automata lives is again a \(d\)-dimensional lattice. One thing special about the world is that it does not have to be a definite lattice. Much like the quantum state of a qubit, the world can be a coherent superposition of different lattices.</p>
</li>
<li><p>Rules: recall our previous discussion on the reversible cellular automata and billiard ball model. The rules necessary to make a reversible and universal computational model requires the following components.   a. A moving signal which is realized as below. \(s\) can take the value of either \(0\) or \(1\).      <img src="image-6.png" alt="alt text" /></p>
<p>b. A mirror: this device is realized via the following block      <img src="image-7.png" alt="alt text" /></p>
<p>c. The time delay: this is realized via the following block       <img src="image-8.png" alt="alt text" /></p>
<p>d. An basis gateset: as per usual in quantum computation, we need a universal basis gateset. The gateset realized in this paper is <code>H</code>, &#36;CR&#40;\pi/4&#41;&#36;,  &#36;R&#40;\pi/4&#41;&#36; and, <code>SWAP</code>. It is not hard to see that this gateset is able to compile out another universal gateset of <code>CNOT</code>, <code>H</code>, and <code>T</code><a href="#footnote-3" class="footnote">[3]</a>. The following diagram are the designs to realize <code>H</code>, &#36;CR&#40;\pi/4&#41;&#36;, &#36;R&#40;\pi/4&#41;&#36;  and <code>SWAP</code> gates respectively.</p>
<p>Hadamard Gate:  <img src="image-9.png" alt="alt text" /></p>
<p>Phase gate gadget and &#36;CR&#40;\pi/4&#41;&#36; gate:  <img src="image-10.png" alt="alt text" />  <img src="image-11.png" alt="alt text" /></p>
<p>&#36;R&#40;\pi/4&#41;&#36; gate:  <img src="image-12.png" alt="alt text" /></p>
</li>
</ol>
<h3 id="22_unitary_and_non-unitary_quantum_cellular_automata_with_rydberg_arrays"><a href="#22_unitary_and_non-unitary_quantum_cellular_automata_with_rydberg_arrays" class="header-anchor">2.2 Unitary and non-unitary quantum cellular automata with Rydberg arrays</a></h3>
<p>The current goal is to implement a quantum cellular automaton with desried rules. The platform of choice is Rydberg atoms. The paper <sup id="fnref:4"><a href="#fndef:4" class="fnref">[3]</a></sup> provides a detailed description of an implementation with multiple-frequency excitation and depumping pulses.</p>
<p>The motivation for the use of Rydberg atom is two fold. Firstly, the control of Rydberg atom system is natrually designed to be homogenous spatially. This corresponds well to the homogeneous evolution rule of a cellular automaton model. Secondly, there&#39;s a nontrivial dissipative interaction that also does not destroy entanglement <sup id="fnref:4"><a href="#fndef:4" class="fnref">[3]</a></sup>. </p>
<p>In the following part of this document, we will first describe the physical platform for the quantum cellular automaton. Then we will describe the numerical simulation of the quantum cellular automaton. Finally, we will discuss the potential of the quantum cellular automaton in the higher dimension regime.</p>
<h3 id="23_physical_platform_for_quantum_cellular_automaton"><a href="#23_physical_platform_for_quantum_cellular_automaton" class="header-anchor">2.3 Physical platform for quantum cellular automaton </a></h3>
<p>The physical platform for the QCA is a 1D array of atoms held in optical microtraps with period \(a\). The atoms are described as a three-state system: \(|g\rangle\), \(|r\rangle\) and an additional short lived state |e〉. Our QCA is a two state CA where \(|g\rangle\) is the \(0\) state and \(|r\rangle\) is the \(1\) state. For visualization, see figure below.</p>
<p><img src="image-20.png" alt="alt text" /></p>
<p>In order to engineer the desired QCA transition function, we will apply a multifrequency coupling field of the following form \(\mathcal{E}_j=\mathcal{E}_j^\theta+\mathcal{E}_j^\phi+\) c.c., where</p>
\[
\begin{aligned}
\mathcal{E}_j^\theta & =\frac{1}{2} \sum_k \theta_j^k \mathrm{e}^{i E_r t+i k V t} \\
\mathcal{E}_j^\phi & =\frac{1}{2} \sum_k \phi_j^k \mathrm{e}^{i\left(E_r-E_e\right) t+i k V t}
\end{aligned}
\]
<p>Special attention should be paid to the factor \(k\) in the exponent. It does not carry physical meaning inherently in the sense that it is defined to be the sum of two number operators. However, in this special setting &#40;1D atom array, it carries the meaning of number of rydberg states in the neighborhood of an atom.&#41;  The \(E_r\) and \(E_g\) term means the energy of the Rydberg and ground state respectively. The \(V\) term is the nearest-neighbor Rydberg-Rydberg interaction strength. The \(\theta_j^k\) and \(\phi_j^k\) are the amplitudes of the different frequency components of the driving fields.</p>
<p>The Hamiltonian of the system is given by </p>
<p>\( \hat{H}(t)=\sum_j \underbrace{\left(\hat{\sigma}_j^{g r} \mathcal{E}_j^\theta(t)+\hat{\sigma}_j^{e r} \mathcal{E}_j^\phi(t)+h . c .\right)+\hat{V}_{\mathrm{int}}}_{\hat{H}_{\mathrm{int}}}+\hat{H}_{\mathrm{atom}},\) </p>
<p>where \(\hat{\sigma}^{a b}=|a\rangle\langle b|, \hat{H}_{\text {atom }}=E_r \hat{\sigma}_j^{r r}+E_e \hat{\sigma}_j^{e e}\). </p>
<p>We could first go to the rotating frame of the Rydberg atom and apply the rotating wave approximation. The Hamiltonian is simplified to </p>
\(\begin{aligned} \hat{H}(t)=\sum_j & \sum_k\left(\frac{\theta_j^k}{2} \hat{\sigma}_j^{g r} \mathrm{e}^{i k V t}+\frac{\left(\theta_j^k\right)^*}{2} \hat{\sigma}_j^{r g} \mathrm{e}^{-i k V t}\right) \\ & +\left(\frac{\phi_j^k}{2} \hat{\sigma}_j^{e r} \mathrm{e}^{i k V t}+\frac{\left(\phi_j^k\right)^*}{2} \hat{\sigma}_j^{r e} \mathrm{e}^{-i k V t}\right)+V \hat{\sigma}_j^{r r} \hat{\sigma}_{j+1}^{r r} .\end{aligned}\)
<p>Then, we could go to the interaction picture of nearest-neighbor Rydberg-Rydberg interaction strength \(V\). The Hamiltonian is simplified to</p>
\(\begin{aligned} \hat{H} & =\sum_j \sum_k\left(\frac{\theta_j^k}{2} \mathrm{P}_{j-1}^0 \hat{\sigma}_j^{g r} \mathrm{P}_{j+1}^0+\frac{\phi_j^k}{2} \mathrm{P}_{j-1}^0 \hat{\sigma}_j^{e r} \mathrm{P}_{j+1}^0\right) \mathrm{e}^{i k V t} \\ & +\left(\frac{\theta_j^k}{2} \mathrm{P}_{j-1}^0 \hat{\sigma}_j^{g r} \mathrm{P}_{j+1}^1+\frac{\phi_j^k}{2} \mathrm{P}_{j-1}^0 \hat{\sigma}_j^{e r} \mathrm{P}_{j+1}^1\right) \mathrm{e}^{i(k-1) V t} \\ & +\left(\frac{\theta_j^k}{2} \mathrm{P}_{j-1}^1 \hat{\sigma}_j^{g r} \mathrm{P}_{j+1}^0+\frac{\phi_j^k}{2} \mathrm{P}_{j-1}^1 \hat{\sigma}_j^{e r} \mathrm{P}_{j+1}^0\right) \mathrm{e}^{i(k-1) V t} \\ & +\left(\frac{\theta_j^k}{2} \mathrm{P}_{j-1}^1 \hat{\sigma}_j^{g r} \mathrm{P}_{j+1}^1+\frac{\phi_j^k}{2} \mathrm{P}_{j-1}^1 \hat{\sigma}_j^{e r} \mathrm{P}_{j+1}^1\right) \mathrm{e}^{i(k-2) V t} \\ & + \text { h.c. }\end{aligned}\)
<p>The \(\mathrm{P}_{j}^0\) and \(\mathrm{P}_{j}^1\) are the projectors onto the ground and Rydberg states respectively. Due to its close resemblance to the PXP model, this is dubbed as <em>effective PXP model</em>. However, it should be noted that the effective PXP model does not inherently prohibit the excitation of blockade state \(|r_i,r_{i+1}\rangle\) </p>
<p>After a few more approximations, we arrive at the time-independent Hamiltonian. </p>
<p>\(\hat{H}^{\prime}=\frac{1}{2} \sum_j \sum_{\alpha, \beta} \mathrm{P}_{j-1}^\alpha\left[\theta_j^k \hat{\sigma}_j^{g r}+\phi_j^k \hat{\sigma}_j^{e r}+\right.\) h.c. \(] \mathrm{P}_{j+1}^\beta\)</p>
<p>Now, we argue that in the limit of \(\phi_j^k >> V > \theta_j^k\), the \(|e\rangle\) state will be short lived. And we could treat it as environment that is coupled to the \(|r\rangle\) and \(|g\rangle\) state non-unitarily.</p>
<p>Finally, we arrive at the Lindblad master equation for describing the overall non-unitary evolution of the system.</p>
\(\partial_t \rho=\mathcal{L}[\rho]=-i[\hat{H}, \rho]+\mathcal{D}[\rho]\)
<p>where \(\hat{H}=\sum_{j, k}\left(\frac{\theta_j^k}{2} e^{i k V t} \hat{\sigma}_j^{g r}+\frac{\phi_j^k}{2} e^{i k V t} \hat{\sigma}_j^{e r}+\right.\) H.c. \()+V \hat{\sigma}_j^{r r} \hat{\sigma}_{j+1}^{r r}\) </p>
<p>and \(\mathcal{D}[\rho]=\sum_j \hat{L}_j \rho \hat{L}_j^{\dagger}-\left(\hat{L}_j^{\dagger} \hat{L}_j \rho+\rho \hat{L}_j^{\dagger} \hat{L}_j\right) / 2\)</p>
<p>Now, we are able to simulate the evolution of each atom in the array according to some specific values of \(\theta_j^k\) and \(\phi_j^k\). This means we could derive the transition function of the quantum cellular automaton from these parameters. As an example, the following figure shows an example of transition rule with the parameter responsible for such transition labeled aside of the arrow. The double sided arrow means the transition is reversible. And, the single sided arrow means the transition is irreversible.</p>
<p><img src="image-13.png" alt="alt text" /></p>
<p>Interested reader should follow <sup id="fnref:4"><a href="#fndef:4" class="fnref">[3]</a></sup> for more details on the derivation of the transition rule.</p>
<h3 id="24_evolution_of_the_quantum_cellular_automaton"><a href="#24_evolution_of_the_quantum_cellular_automaton" class="header-anchor">2.4 Evolution of the quantum cellular automaton</a></h3>
<p>There are two modes of evolution for the quantum cellular automaton. The first one is continuous. You simply let the system evolve according to the Lindblad master equation. Such pattern of Rydberg atoms are displayed in the right section of the figure below. The parameters are displayed on the top of each evolution in the format of \([\theta_j^0, \theta_j^1, \theta_j^2, \tilde{\phi_j^0}, \tilde{\phi_j^1},\tilde{\phi_j^2}]\) where \(\tilde{\phi_j^k} \approx \phi_j^k/\sqrt{\Gamma}\). The color of each cell represents the \(<Z_j>\) expectation of Pauli Z spin on that site.</p>
<p>The second evolution is discrete. It is essentially the blocked evolution rule from <sup id="fnref:1"><a href="#fndef:1" class="fnref">[1]</a></sup>. You let the system evolve according to the transition rule derived from the parameters \(\theta_j^k\) and \(\phi_j^k\). However, at odd times, you apply the part of the Lindbladian that evolves the atoms on the odd sites. At even times, you apply the part of the Lindbladian that evolves the even site atoms. Such simulation is displayed on the left.  </p>
<p><img src="image-16.png" alt="alt text" /></p>
<p>The simulation is reconstructed in this <a href="https://github.com/exAClior/TinyQCASim.jl">repository</a> based on QuTip<sup id="fnref:5"><a href="#fndef:5" class="fnref">[4]</a></sup>.</p>
<h3 id="31_implementation_of_ca_with_quantum_gates"><a href="#31_implementation_of_ca_with_quantum_gates" class="header-anchor">3.1 Implementation of CA with quantum gates</a></h3>
<p>Previously, we performed numerical simulation of an RCA with cell states corresponding to the \(|0\rangle\) and \(|1\rangle\) of a Rydberg atom qubit. </p>
<p><img src="image-16.png" alt="alt text" /></p>
<p>On the right side of the figure, we have transition rules that achieves a transition from computational basis to a superposition of computational basis state. This is evident from the fact that color of the cell is no longer only black and yellow. This means we could implement a QCA with pulse level control. However, this requires some redesign of the exisitng physical platform, we would like to know whether there is a simpler way to implement a QCA with gate level control.</p>
<p>Now, the uncertainty is how to implement an QCA with more than 2 states with a Rydberg qubit system as in the Arrighi et al<sup id="fnref:6"><a href="#fndef:6" class="fnref">[5]</a></sup>. We propose to use two \(gg\) Rydberg qubits to represent a cell in the QCA. The four states of the cell are represented by the following states of the two qubits: </p>
<p>\(\epsilon = |gg\rangle\), \(|0\rangle = |gg'\rangle\), \(|1\rangle = |g'g\rangle\), \(\blacksquare = |g'g'\rangle\).</p>
<p>The corresponding notation of states are layedout in the figure below. <img src="image-14.png" alt="alt text" /></p>
<h3 id="32_state_quantum_transition_rules"><a href="#32_state_quantum_transition_rules" class="header-anchor">3.2 State Quantum Transition Rules</a></h3>
<p>We propose to implement the \(4\)-state QCA in Arrighi&#39;s paper<sup id="fnref:6"><a href="#fndef:6" class="fnref">[5]</a></sup>. A \(4\)-state cell could be achieved with \(2\) Rydberg atom qubits combined together, each of which will be using \(|g\rangle\) and \(|g'\rangle\) as computational basis. </p>
<p>The rules such as </p>
<p><img src="image-6.png" alt="alt text" /> would be columns of a \(4^4 \times 4^4\) unitary matrix. The problem is that we need to find a way to compile the unitary matrix into a sequence of basis gates. This requires us to do quantum circuit compilation.</p>
<p>For instance, the first rule in the figure above could be represented by the following unitary matrix in dirac notation: \(\frac{1}{\sqrt{2}}( |11000111 \rangle + |11001011\rangle) \langle 11010011|\)</p>
<h3 id="41_circuit_compilation"><a href="#41_circuit_compilation" class="header-anchor">4.1 Circuit Compilation</a></h3>
<p>Quantum Circuit Compilation is the process of converting a \(d \times d\) unitary matrix into a sequence of basis gates \(\{B\}\). Usually, gates in \(\{B\}\) act non-trivially only on \(1\) or \(2\) qubits. One common example of the basis gateset is \(\{H, S, T, CNOT\}\). It is necessary to compile the unitary matrix into a sequence of basis gates because the error correction is only possible when the we don&#39;t have a continuous degree of freedom to control on basis gates. Because it would require infinite amount of information to exacly know and fix the gate that is implemented with error.</p>
<p>The classical method of doing this is layed out in Chapter 4.5 in Nielson and Chuang<sup id="fnref:3"><a href="#fndef:3" class="fnref">[6]</a></sup>. </p>
<h3 id="42_classical_method"><a href="#42_classical_method" class="header-anchor">4.2 Classical Method</a></h3>
<p>In this section, we give a constructive proof of how to decompose a \(d \times d\) unitary matrix into a sequence of \(2-level\) unitaries.  </p>
<p>We claim that any \(d \times d\) unitary matrix \(U\) can be decomposed into a sequence of \(2\)-level unitaries, \(U_i^{\dagger}\).  I.e \(\prod_i U_i^{\dagger} = U\).</p>
<p>A two level unitary is a unitary matrix that acts non-trivially only on the subspace spanned by two computational basis states. For example, the following matrix is a \(2\)-level unitary that acts only on the subspace spanned by \(|0\rangle\) and \(|1\rangle\):</p>
\[
U_1 \equiv\left[\begin{array}{ccc}
\frac{a^*}{\sqrt{|a|^2+|b|^2}} & \frac{b^*}{\sqrt{|a|^2+|b|^2}} & 0 \\
\frac{b}{\sqrt{|a|^2+|b|^2}} & \frac{-a}{\sqrt{|a|^2+|b|^2}} & 0 \\
0 & 0 & 1
\end{array}\right] .
\]
<p>The purpose of such \(2\)-level unitaries is to act non-trivially only on the subspace spanned by two computational basis states.</p>
<p>For the sake of simplicity in explaination, let&#39;s assume that such subspaces are spanned by the two states \(|0aaaaa\rangle\) and \(|1aaaaa\rangle\). I.e in the subspace of the first qubit. Any \(2\)-level unitary acts trivially on the other qubits. Therefore, the \(2\)-level unitary is a tensor product of a \(2 \times 2\) unitary matrix and the identity matrix on other matrices. We could always visualize the \(2 \times 2\) matrix as a rotation in the Bloch sphere. </p>
<p>The number of \(2\)-level unitaries required to decompose a \(d \times d\) unitary matrix is \(O(d^2)\). Naively, we need to do a rotation that zeros out each off-diagonal terms.</p>
<p>Here we introduce how to simulate general contral-U gates,we will introduce the notation and lemma that we will use in the following part.</p>
<p><strong>Notation:</strong> \(\mathrm{R}_{\mathrm{y}}(\theta)=\left(\begin{array}{rr}\cos \theta / 2 & \sin \theta / 2 \\ -\sin \theta / 2 & \cos \theta / 2\end{array}\right)\) &#40;a rotation by \(\theta\) around \(\left.\hat{y}\right)\) \(\mathrm{R}_{\mathrm{z}}(\alpha)=\left(\begin{array}{ll}e^{i \alpha / 2} & 0 \\ 0 & e^{-i \alpha / 2}\end{array}\right)(\) a rotation by \(\alpha\) around \(\hat{z})\). \(\operatorname{Ph}(\delta)=\left(\begin{array}{ll}e^{i \delta} & 0 \\ 0 & e^{i \delta}\end{array}\right)\) &#40;a phase-shift with respect to \(\delta\) &#41;. \(\sigma_x=\left(\begin{array}{ll}0 & 1 \\ 1 & 0\end{array}\right)\) &#40;a &quot;negation&quot;, or Pauli matrix&#41;. \(I=\left(\begin{array}{ll}1 & 0 \\ 0 & 1\end{array}\right)\) &#40;the identity matrix&#41;.</p>
<p><strong>Lemma 1</strong>: The following properties hold:</p>
<ol>
<li><p>\(\mathrm{R}_{\mathrm{y}}\left(\theta_1\right) \cdot \mathrm{R}_{\mathrm{y}}\left(\theta_2\right)=\mathrm{R}_{\mathrm{y}}\left(\theta_1+\theta_2\right)\)</p>
</li>
<li><p>\(\mathrm{R}_{\mathrm{z}}\left(\alpha_1\right) \cdot \mathrm{R}_{\mathrm{z}}\left(\alpha_2\right)=\mathrm{R}_{\mathrm{z}}\left(\alpha_1+\alpha_2\right)\)</p>
</li>
<li><p>\(\operatorname{Ph}\left(\delta_1\right) \cdot \operatorname{Ph}\left(\delta_2\right)=\operatorname{Ph}\left(\delta_1+\delta_2\right)\)</p>
</li>
<li><p>\(\sigma_x \cdot \sigma_x=I\)</p>
</li>
<li><p>\(\sigma_x \cdot \mathrm{R}_{\mathrm{y}}(\theta) \cdot \sigma_x=\mathrm{R}_{\mathrm{y}}(-\theta)\)</p>
</li>
<li><p>\(\sigma_x \cdot \mathrm{R}_{\mathrm{z}}(\alpha) \cdot \sigma_x=\mathrm{R}_{\mathrm{z}}(-\alpha)\)</p>
</li>
</ol>
<p><strong>Lemma 2（ZYZ Decompostition）</strong>: Every unitary \(2 \times 2\) matrix can be expressed as</p>
\[
\left(\begin{array}{ll}
e^{i \delta} & 0 \\
0 & e^{i \delta}
\end{array}\right) \cdot\left(\begin{array}{ll}
e^{i \alpha / 2} & 0 \\
0 & e^{-i \alpha / 2}
\end{array}\right) \cdot\left(\begin{array}{rl}
\cos \theta / 2 & \sin \theta / 2 \\
-\sin \theta / 2 & \cos \theta / 2
\end{array}\right) \cdot\left(\begin{array}{ll}
e^{i \beta / 2} & 0 \\
0 & e^{-i \beta / 2}
\end{array}\right),
\]
<p>where \(\delta, \alpha, \theta\), and \(\beta\) are real-valued. Moreover, any special unitary \(2 \times 2\) matrix &#40;i.e., with unity determinant&#41; can be expressed as</p>
\[
\left(\begin{array}{ll}
e^{i \alpha / 2} & 0 \\
0 & e^{-i \alpha / 2}
\end{array}\right) \cdot\left(\begin{array}{rr}
\cos \theta / 2 & \sin \theta / 2 \\
-\sin \theta / 2 & \cos \theta / 2
\end{array}\right) \cdot\left(\begin{array}{ll}
e^{i \beta / 2} & 0 \\
0 & e^{-i \beta / 2}
\end{array}\right) =\mathrm{R}_{\mathrm{z}}(\alpha) \cdot \mathrm{R}_{\mathrm{y}}(\theta) \cdot \mathrm{R}_{\mathrm{z}}(\beta) .
\]
<p><strong>Lemma 3</strong>: For any special unitary matrix \(W(W \in S U(2))\), there exist matrices \(A, B\), and \(C \in S U(2)\) such that \(A \cdot B \cdot C=I\) and \(A \cdot \sigma_x \cdot B \cdot \sigma_x \cdot C=W\)</p>
<p>Proof: By Lemma 2, there exist \(\alpha, \theta\), and \(\beta\) such that \(W=\mathrm{R}_{\mathrm{z}}(\alpha) \cdot \mathrm{R}_{\mathrm{y}}(\theta) \cdot \mathrm{R}_{\mathrm{z}}(\beta)\). Set \(A=\mathrm{R}_{\mathrm{z}}(\alpha) \cdot \mathrm{R}_{\mathrm{y}}\left(\frac{\theta}{2}\right), B=\mathrm{R}_{\mathrm{y}}\left(-\frac{\theta}{2}\right) \cdot \mathrm{R}_{\mathrm{z}}\left(-\frac{\alpha+\beta}{2}\right)\), and \(C=\mathrm{R}_{\mathrm{z}}\left(\frac{\beta-\alpha}{2}\right)\). Then</p>
\[
\begin{aligned}
A \cdot B \cdot C & =\mathrm{R}_{\mathrm{z}}(\alpha) \cdot \mathrm{R}_{\mathrm{y}}\left(\frac{\theta}{2}\right) \cdot \mathrm{R}_{\mathrm{y}}\left(-\frac{\theta}{2}\right) \cdot \mathrm{R}_{\mathrm{z}}\left(-\frac{\alpha+\beta}{2}\right) \cdot \mathrm{R}_{\mathrm{z}}\left(\frac{\beta-\alpha}{2}\right) \\
& =\mathrm{R}_{\mathrm{z}}(\alpha) \cdot \mathrm{R}_{\mathrm{z}}(-\alpha) \\
& =I
\end{aligned}
\]
<p><strong>Theorem 1</strong>: For any unitary \(2 \times 2\) matrix \(W\), a contral-\((W)\) gate can be simulated by a network of the form,where \(A, B\), and \(C \in S U(2)\), if and only if \(W \in S U(2)\). <img src="image-15.png" alt="alt text" /> Proof: For the &quot;if&quot; part, let \(A, B\), and \(C\) be as in Lemma 3. If the value of the first &#40;top&#41; bit is 0 then \(A \cdot B \cdot C=I\) is applied to the second bit. If the value of the first bit is 1 then \(A \cdot \sigma_x \cdot B \cdot \sigma_x \cdot C=W\) is applied to the second bit. For the &quot;only if&quot; part, note that \(A \cdot B \cdot C=I\) must hold if the simulation is correct when the first bit is 0 . Also, if the network simulates a contral\((W)\) gate then \(A \cdot \sigma_x \cdot B \cdot \sigma_x \cdot C=W\). Therefore, since \(\operatorname{det}\left(A \cdot \sigma_x \cdot B \cdot \sigma_x \cdot C\right)=1, W\) must also be special unitary.</p>
<h3 id="43_advanced_method_decompose_to_2-level_unitaries"><a href="#43_advanced_method_decompose_to_2-level_unitaries" class="header-anchor">4.3 Advanced Method &amp; Decompose to 2-level unitaries </a></h3>
<p>A brief search on the internet shows that this is still the state-of-the-art method for quantum circuit compilation without considering topology and noise. Firstly, we will decompose \(256 \times 256\) unitary matrix, \(U\), into a sequence of \(2\)-level matrices. </p>
<p>There are various ways of doing it. </p>
<p>We don&#39;t recommend the following <a href="https://arxiv.org/pdf/2304.14096.pdf">method</a> because it is a costly optimization based one with no guarantee of the circuit depth.</p>
<p><a href="https://arxiv.org/pdf/quant-ph/0507171.pdf">Cartan&#39;s KAK decomposition</a> and <a href="https://quantumai.google/reference/python/cirq/kak_decomposition">realization</a></p>
<p>Rather, let&#39;s approach this problem with there different decomposition methods. In general, they will decompose the unitary matrix into a sequence of \(2\)-level unitaries.</p>
<p>Some collection of literature are listed here approximately chronologically:</p>
<ol>
<li><p><a href="https://cba.mit.edu/docs/theses/01.05.aram.pdf">Aram Harrow&#39; PhD thesis</a>. This is a good starting point but perhaps too old.</p>
</li>
</ol>
<ol start="2">
<li><p><a href="https://arxiv.org/pdf/quant-ph/0404089.pdf">An early synthesis algorithm</a></p>
</li>
<li><p><a href="https://arxiv.org/pdf/2101.02993.pdf">The most promising implementation</a></p>
</li>
</ol>
<h3 id="44_optimization"><a href="#44_optimization" class="header-anchor">4.4 Optimization</a></h3>
<p>We could try to optimize the compiled gates specifically for the Rydberg atom system. For example, try to following <a href="https://arxiv.org/pdf/2306.03487.pdf">this</a> paper.</p>
<p>Furthermore, we could try to optimize the compiled gates for the Rydberg atom system. Due to its current worst quality and requirement for optimization on the topology level, we set the number of <a href="https://arxiv.org/pdf/quant-ph/0308033.pdf">CNOT</a> as the target for optimization. Note that there&#39;s an lower bound for the number of CNOT used in an \(n\)-qubit gate \(\frac{1}{4}(4^n - 3n - 1)\), please see proof in the previous link.</p>
<h3 id="51_universal_quantum_gates_and_generic_gates"><a href="#51_universal_quantum_gates_and_generic_gates" class="header-anchor">5.1 Universal Quantum Gates and Generic Gates</a></h3>
<p>In the study of classical computation &#40;reversible and irreversible&#41;, it has been proven that any function operation can be decomposed into a combination of a finite number of basic gates<sup id="fnref:7"><a href="#fndef:7" class="fnref">[7]</a></sup>. In other words, by constructing universal logic gates, any function calculation can be realized. The combination of basic gates forms a circuit model, and the scale of the basic gates naturally gives the circuit complexity of the corresponding computation.<sup id="fnref:14"><a href="#fndef:14" class="fnref">[8]</a></sup></p>
<blockquote>
<p>Universality of classical logic gates: The combination of classical <strong>universal</strong> logic gates can accurately obtain any Boolean function.</p>
</blockquote>
<blockquote>
<p>Universality of quantum logic gates: Quantum circuits generated through cascading universal gates can approximate any unitary transformation in an \(n\)-qubit space to any desired precision.</p>
</blockquote>
<h5 id="definition1_if_fracab_is_a_rational_number_then_a_and_b_are_called_commensurate_otherwise_they_are_called_incommensurate"><a href="#definition1_if_fracab_is_a_rational_number_then_a_and_b_are_called_commensurate_otherwise_they_are_called_incommensurate" class="header-anchor">Definition1: If \(\frac{a}{b}\) is a rational number, then a and b are called commensurate; otherwise, they are called incommensurate.</a></h5>
<p>From the properties of real numbers, we can obtain the following lemma:</p>
<h5 id="lemma1_if_the_angle_theta_in_ei_theta_is_incommensurate_with_pi_then_ei_n_theta_n12_cdots_infty_is_dense_on_the_unit_circle_in_the_complex_planesup_idfnref12a_hreffndef12_classfnref9"><a href="#lemma1_if_the_angle_theta_in_ei_theta_is_incommensurate_with_pi_then_ei_n_theta_n12_cdots_infty_is_dense_on_the_unit_circle_in_the_complex_planesup_idfnref12a_hreffndef12_classfnref9" class="header-anchor">Lemma1: If the angle \(\theta\) in \(e^{i \theta}\) is incommensurate with \(\pi\), then \(e^{i n \theta}\) \((n=1,2, \cdots, \infty)\) is dense on the unit circle in the complex plane<sup id="fnref:12"><a href="#fndef:12" class="fnref">[9]</a></sup></a></h5>
<p><strong>Proof：</strong> The incommensurability of \(\theta\) and \(\pi\) implies that \(\theta / \pi\) is irrational. By contradiction, if \(\theta=\frac{p}{q} \pi\) &#40;\(p, q\) are integers, and any number that can be written as a fraction is rational&#41;, then, by the periodicity of the function \(e^{i a}\), we know that \(e^{i 2 q \theta}=e^{i 2 p \pi}=1\). \(e^{i n \theta}\) \((n=1,2, \cdots)\) is periodic, and it can only cover a finite number of points on the unit circle, so it cannot be dense &#40;denseness implies that it can be arbitrarily close to any point \(e^{i \Phi}\) on the unit circle using a sequence \(e^{i f(n) \theta}\), where \(f(n)\) is a function of the natural number \(n\)&#41;. &#40;Generic gates can be seen as a generalization of this property on unitary matrices&#41;.</p>
<p>Any unitary transformation \(U\) can be similar to this diagonal form &#40;in the corresponding eigenstate representation<sup id="fnref:9"><a href="#fndef:9" class="fnref">[10]</a></sup>）:</p>
\[
U_g=\left[\begin{array}{llll}
e^{i \theta_1} & & & \\
& e^{i \theta_2} & & \\
& & \ddots & \\
& & & e^{i \theta_{2^k}}
\end{array}\right]
\]
<p><strong>Definition: If a unitary transformation satisfies the following two constraints, it is called a k-qubit generic gate &#40;denoted as \(U_g\)&#41;</strong>  &#40;1&#41; All \(\theta_i\) are incommensurate with \(\pi\).  &#40;2&#41;Any two \(\theta_i\) and \(\theta_j(i \neq j)\) are incommensurate with each other.</p>
<p>The first condition is consistent with the condition in Lemma 1, which ensures that each \(e^{i n \theta_j}\) \((n=1,2, \cdots, \infty)\) is dense on the corresponding unit circle. The second condition ensures that different \(e^{i \theta_j}\) are unrelated and independent of each other. If the diagonal elements of the positive integer powers \(U_g^n\) of the generation gate \(U_g\) \(\left(e^{i n \theta_1}, e^{i n \theta_2}, \cdots, e^{i n \theta_{2^k}}\right)\) are viewed as points on a \(2^k\) -dimensional torus, then as \(n\) increases from 1, these points move on the \(2^k\) -dimensional torus. As \(n \Longrightarrow \infty\), these points gradually become dense, meaning for any point \(\left(e^{i \alpha_1}, e^{i \alpha_2}, \cdots, e^{i \alpha_{2^k}}\right)\), there exists an infinite sequence \(\left\{U_g^{m_1}, U_g^{m_2}, \cdots, U_g^{m_i}, \cdots\right\}\) such that \(\left(e^{i m_j \theta_1}, e^{i m_j \theta_2}, \cdots, e^{i m_j \theta_{2^k}}\right)\) &#40;as \(m_j\) tends to infinity&#41; can approximate \(\left(e^{i \alpha_1}, e^{i \alpha_2}, \cdots, e^{i \alpha_{2^k}}\right)\) arbitrarily closely.</p>
<h5 id="lemma_2_if_u_1ei_a_u_2ei_b_a_b_is_hermitian_are_generating_gates_then_any_unitary_transformation_ei_l_can_be_generated_by_their_concatenation_where_l_is_any_element_in_the_lie_algebra_mathcalla_b_generated_by_the_operators_a_b"><a href="#lemma_2_if_u_1ei_a_u_2ei_b_a_b_is_hermitian_are_generating_gates_then_any_unitary_transformation_ei_l_can_be_generated_by_their_concatenation_where_l_is_any_element_in_the_lie_algebra_mathcalla_b_generated_by_the_operators_a_b" class="header-anchor">Lemma 2: If \(U_1=e^{i A}, U_2=e^{i B}\) &#40;\(A, B\) is Hermitian&#41; are generating gates, then any unitary transformation \(e^{i L}\) can be generated by their concatenation, where \(L\) is any element in the Lie algebra \(\mathcal{L}(A, B)\) generated by the operators \(A, B\).</a></h5>
<p><strong>Proof：This is equivalent to proving the following two facts:</strong> &#40;1&#41; Any unitary transformation \(e^{i(\alpha A+\beta B)}\) &#40;where \(\alpha, \beta\) are arbitrary real numbers&#41; can be approximated arbitrarily closely by cascading the generating gates \(U_1\) and \(U_2\).  &#40;2&#41; Any unitary transformation \(e^{-\gamma[A, B]}\) &#40;where \(\gamma\) is an arbitrary real number&#41; can be approximated arbitrarily closely by cascading the generating gates \(U_1\) and \(U_2\). Since \(U_1\) is a generating gate, there exists a series of powers of \(U_1\).</p>
\[
e^{i f(1) A}, e^{i f(2) A}, \cdots, e^{i f(j) A}, \cdots
\]
<p>Any unitary transformation \(U_1(\lambda)=e^{i \lambda A}\) &#40;where \(\lambda\) is an arbitrary real number&#41; can be approximated arbitrarily closely. Similarly, the unitary transformation \(U_2(\lambda)=e^{i \lambda B}\) &#40;where \(\lambda\) is an arbitrary real number&#41; can also be approximated by powers of \(U_2\). Based on this, we have:</p>
\[
\begin{aligned}
e^{i(\alpha A+\beta B)} & =\lim _{n \Longrightarrow \infty}\left[e^{i \frac{\alpha A+\beta B}{n}}\right]^n \\
& =\lim _{n \Longrightarrow \infty}\left(1+i \frac{\alpha A+\beta B}{n}\right)^n \\
& =\lim _{n \Longrightarrow \infty}\left[\left(1+i \frac{\alpha A}{n}\right)\left(1+i \frac{\beta B}{n}\right)\right]^n\\
& =\lim _{n \Longrightarrow \infty}\left(e^{i \frac{\alpha A}{n}} e^{i \frac{\beta B}{n}}\right)^n
\end{aligned}
\]
<p>Therefore, \(e^{i(\alpha A+\beta B)}\) can be generated by concatenating \(e^{i \frac{\alpha}{n} A}\) &#40;generated by powers of \(U_1\)&#41; and \(e^{i \frac{\beta}{n} B}\) &#40;generated by powers of \(U_2)\). This proves the first fact. As for the second fact, we similarly have:</p>
\[
\begin{aligned}
e^{-\gamma[A, B]} & =\lim _{n \Longrightarrow \infty}\left[e^{\frac{-\gamma[A, B]}{n}}\right]^n \\
& =\lim _{n \Longrightarrow \infty}\left[1-\frac{\gamma}{n}(A B-B A)\right]^n \\
& =\lim _{n \Longrightarrow \infty}\left(e^{i \sqrt{\frac{\gamma}{n}} A} e^{i \sqrt{\frac{\gamma}{n}} B} e^{-i \sqrt{\frac{\gamma}{n}} A} e^{-i \sqrt{\frac{\gamma}{n}} B}\right)^n
\end{aligned}
\]
<p>Therefore, \(e^{-\gamma[A, B]}\) can also be generated by concatenating \(U_1\) and \(U_2\). It can be seen that any unitary transformation corresponding to an arbitrary linear combination of operators \(A,B\), and the commutator \([A, B]\), can be generated by concatenating the generating gates \(U_1, U_2\). More generally, by iteratively performing commutation operations on the operators &#40;such as \([[A, B], A],[[[A, B], A], A], \cdots\)&#41;, until the entire set of operators is closed &#40;i.e., no new operators are produced by commutation&#41;, a closed Lie algebra \(\mathcal{L}(A, B)\) generated by the operators \(A\) and \(B\) is formed. Therefore, any unitary transformation \(e^{i L}\) corresponding to any operator \(L\) in the Lie algebra \(\mathcal{L}(A, B)\) can be realized by concatenating the generating gates \(e^{i A}\) and \(e^{i B}\).</p>
<p>If a logical gate \(M\) can be arbitrarily approximated by concatenating a set of generating gates \(e^{i \theta A_k}\) &#40;where \(k=1,2, \cdots, n\)&#41;, then \(M\) can generate the unitary transformation \(e^{i \mathcal{L}}\) corresponding to the entire Lie algebra \(\mathcal{L}\left(A_1, A_2, \cdots, A_n\right)\). In particular, if any Hermitian operator in an \(n\)-qubit system is in \(\mathcal{L}\left(A_1, A_2, \cdots, A_n\right)\), then the logical gate \(M\) can generate all unitary transformations on the \(n\) qubits. Therefore, \(M\) is a universal quantum logical gate.</p>
<h3 id="52_clifford_group"><a href="#52_clifford_group" class="header-anchor">5.2 Clifford Group*</a></h3>
<p>To define the Clifford operator, we first define the Pauli group \(\mathcal{P}_1\) on a single qubit, which is defined as the group generated by the operators \(\left\{i, \sigma^x, \sigma^z\right\}\) through multiplication, and it contains a total of 16 elements:</p>
\[
\left\{ \pm I, \pm \sigma^x, \pm \sigma^y, \pm \sigma^z, \pm i I, \pm i \sigma^x, \pm i \sigma^y, \pm i \sigma^z\right\}
\]
<p>The Pauli group \(\mathcal{P}_n\) on \(n\) qubits is defined as follows: </p>
\[
\left\langle i, \sigma_1^x, \sigma_1^z, \sigma_2^x, \sigma_2^z, \cdots, \sigma_n^x, \sigma_n^z\right\rangle .
\]
<p>Therefore, the Clifford group on the Pauli group \(\mathcal{P}_n\) is defined as follows:  **Definition： &#40;Clifford group&#41; If the \(n\)-qubit operator \(g \in \mathrm{SU}\left(2^n\right)\) satisfies the condition for any element \(p \in \mathcal{P}_n\) in the Pauli group such that<sup id="fnref:13"><a href="#fndef:13" class="fnref">[11]</a></sup></p>
\[
g p g^{-1} \in \mathcal{P}_n
\]
<p>**</p>
<p>then the operator \(g\) is called an \(n\)-qubit Clifford operator. All Clifford operators \(g\) form a group structure, known as the \(n\)-qubit Clifford group.<sup id="fnref:11"><a href="#fndef:11" class="fnref">[12]</a></sup><sup id="fnref:12"><a href="#fndef:12" class="fnref">[9]</a></sup> &#40;The coefficients in front of the elements do not play a role when considering the commutation relations of Pauli group elements&#41;. In this case, the elements of the Pauli group can be represented by the generators \(\sigma_i^x, \sigma_i^z\) . <strong>Table 1:Closure of the Pauli Group under Clifford Action</strong></p>
<p>The first column on the left represents single-qubit Pauli operators, the first row at the top represents single-qubit Clifford operators, and the table below shows the results of the Clifford operators acting on the corresponding Pauli operators. It can be observed that the Pauli operators remain in the Pauli group after the Clifford action. | Pauli \(\backslash\) Clifford | \(\sigma^x\) | \(\sigma^z\) | \(\sqrt{i \sigma^x}\) | \(\sqrt{i \sigma^y}\) | \(\sqrt{i \sigma^z}\) | \(H\) | \(S\) | | :–-: | :–-: | :–-: | :–-: | :–-: | :–-: | :–-: | :–-: | | \(\sigma^x\) | \(\sigma^x\) | \(-\sigma^x\) | \(\sigma^x\) | \(\sigma^z\) | \(-\sigma^y\) | \(\sigma^z\) | \(\sigma^y\) | | \(\sigma^y\) | \(-\sigma^y\) | \(-\sigma^y\) | \(-\sigma^z\) | \(\sigma^y\) | \(\sigma^x\) | \(-\sigma^y\) | \(-\sigma^x\) | | \(\sigma^z\) | \(-\sigma^z\) | \(\sigma^z\) | \(\sigma^y\) | \(-\sigma^x\) | \(\sigma^z\) | \(\sigma^x\) | \(\sigma^z\) |</p>
<p>By utilizing the properties of Pauli operators, it is straightforward to verify the correctness of the operations in the table. In particular, the Clifford operator can be expressed as: </p>
\[
\sqrt{i \sigma^k}=e^{i \frac{\pi}{4} \sigma^k}=\frac{\sqrt{2}}{2}\left(I+i \sigma^k\right), \quad k=x, y, z
\]
<p>Next, we will examine the Clifford properties of the CNOT gate. The CNOT gate can be represented in operator form as:</p>
\[
\mathrm{CNOT}=\frac{1}{2}\left(I \otimes I+\sigma^z \otimes I+I \otimes \sigma^x-\sigma^z \otimes \sigma^x\right)
\]
<p><strong>Table 2: Some typical transformations of two-qubit Pauli operators under the action of the CNOT gate are provided.</strong> The typical transformation of two-qubit Pauli operators under the CNOT gate is as follows: the first four operators are the basic operators, and the other operators can be generated through the multiplication of these basic operators. For example, the result of the operator \(\sigma^y \otimes \sigma^y\) after passing through the CNOT gate can be obtained through the product of the first four operators.</p>
<table><tr><th align="center">Clifford \(\backslash\) Pauli</th><th align="center">\(\sigma^x \otimes I\)</th><th align="center">\(\sigma^z \otimes I\)</th><th align="center">\(I \otimes \sigma^x\)</th><th align="center">\(I \otimes \sigma^z\)</th><th align="center">\(\sigma^y \otimes \sigma^y\)</th></tr><tr><td align="center">\(\mathrm{CNOT}\)</td><td align="center">\(\sigma^x \otimes \sigma^x\)</td><td align="center">\(\sigma^z \otimes I\)</td><td align="center">\(I \otimes \sigma^x\)</td><td align="center">\(\sigma^z \otimes \sigma^z\)</td><td align="center">\(\sigma^x \otimes \sigma^z\)</td></tr></table>
<p>From Table 2, it can be observed that when the control qubit contains the operator \(\sigma^x\) it will propagate to the target qubit through the CNOT gate, while the operator \(\sigma^z\) will not propagate to the target qubit. Conversely, when the target qubit contains the operator \(\sigma^z\), the CNOT gate will propagate it to the control qubit, whereas the operator \(\sigma^x\) will not propagate to the control qubit. The distinct actions of the CNOT gate on the operators \(\sigma^x\) and \(\sigma^z\) for the control and target qubits play a crucial role in fault-tolerant quantum computation.</p>
<p>For an \(n\)-qubit system, we have the following theorem for the Clifford group:  <strong>Theorem: The \(n\)-qubit Clifford group can be generated by single-qubit \(S\) gates, \(H\) gates, and two-qubit CNOT gates.</strong> While Clifford operators have many elegant properties, including only Clifford gates is not sufficient to achieve universal quantum computation. Therefore, we will introduce the well-known Gottesman-Knill theorem.</p>
<h3 id="53_the_gottesman-knill_theorem_and_its_proof"><a href="#53_the_gottesman-knill_theorem_and_its_proof" class="header-anchor">5.3 The Gottesman-Knill theorem and its proof</a></h3>
<h4 id="theoremgottesman-knill_theoremif_a_quantum_circuit_consists_only_of_the_following_operationssup_idfnref11a_hreffndef11_classfnref12sup_idfnref13a_hreffndef13_classfnref11"><a href="#theoremgottesman-knill_theoremif_a_quantum_circuit_consists_only_of_the_following_operationssup_idfnref11a_hreffndef11_classfnref12sup_idfnref13a_hreffndef13_classfnref11" class="header-anchor">Theorem：（Gottesman-Knill Theorem）If a quantum circuit consists only of the following operations<sup id="fnref:11"><a href="#fndef:11" class="fnref">[12]</a></sup><sup id="fnref:13"><a href="#fndef:13" class="fnref">[11]</a></sup>：</a></h4>
<p>（1）Preparation of the initial state in the computational basis; （2） Clifford gates; （3）Measurements in the computational basis, then, this quantum circuit can be efficiently simulated by a classical computer. <strong>Proof：</strong> Let \(C_n\) be a quantum circuit composed of Clifford gates, corresponding to the Clifford operator \(U\) .According to condition &#40;1&#41;, the input quantum state \(\left|\phi_0\right\rangle\) of this quantum circuit \(C_n\) needs to be prepared in the computational basis. Without loss of generality, we assume \(\left|\phi_0\right\rangle=\left|0^n\right\rangle\) &#40;if the input state on some qubits is \(|1\rangle\), we only need to add a \(\sigma^x\) gate at the corresponding qubit input position in the circuit \(C_n\) to form a new circuit \(C_n^{\prime}\)&#41;. It is worth noting that the initial state \(\left|\phi_0\right\rangle=\left|0^n\right\rangle\) satisfies the eigenvalue equation \(\sigma_i^z\left|\phi_0\right\rangle=\left|\phi_0\right\rangle(i=1,2, \cdots, n)\); in other words, \(\left|\phi_0\right\rangle=\left|0^n\right\rangle\) is the unique common eigenstate with eigenvalue 1 of \(\sigma_i^z(i=1,2, \cdots, n)\). The output state &#40;final state&#41; \(\left|\phi_f\right\rangle\) of \(C_n\) satisfies the following equation:</p>
\[
\left|\phi_f\right\rangle=U\left|0^n\right\rangle=U \sigma_i^z U^{\dagger} U\left|0^n\right\rangle \quad(i=1,2, \cdots, n)
\]
<p>This indicates that the final state \(\left|\phi_f\right\rangle\) is the unique common eigenstate with eigenvalue &#43;1 of the Pauli operator \(Q_i=U \sigma_i^z U^{\dagger} \quad(i=1,2, \cdots, n)\) &#40;where \(Q_i\) commute with each other and are mutually independent&#41;. To effectively simulate the quantum circuit \(C_n\), it is necessary to be able to efficiently compute the probability of the output quantum state \(\left|\phi_f\right\rangle\) in any computational basis \(|x\rangle\).Without loss of generality, let \(|x\rangle=\left|0^n\right\rangle\) &#40;if the quantum state of some qubits in the computational basis \(|x\rangle\) is \(|1\rangle\), it is only necessary to add a \(\sigma^x\) gate at the output position of the corresponding qubits in the quantum circuit \(C_n\) to form a new circuit \(C_n^{\prime}\)&#41;. Since simultaneous measurements and individual measurements do not affect the final distribution probability, without loss of generality, we discuss the measurements in a bit-by-bit manner. &#40;1&#41; The commutation relations between the operators \(\sigma_1^z, \sigma_2^z, \cdots\) and the operators in the set \(\left\{Q_i\right\}\) are sequentially considered. Let \(\sigma_{a_1}^z\) be the first \(\sigma^z\) operator that has a commutation relation with some operators in the set \(\left\{Q_i \mid i=1,2, \cdots, n\right\}\).</p>
<p>In other words, all operators in the set\(\left\{Q_i \mid i=\right.\) \(1,2, \cdots, n\}\) commute with the operators \(\sigma_j^z\) when \(j<a_1\), let the operators in\(\left\{Q_i \mid i=1,2, \cdots, n\right\}\) which commute with \(\sigma_{a_1}^z\) form the set \(\mathcal{S}_1\), and the operators commute with \(\sigma_{a_1}^z\) form the set \(\mathcal{S}_2\) .Since \(\mathcal{S}_1\) is not empty, let&#39;s assume \(Q_k \in \mathcal{S}_1\) and \(|\phi\rangle\) be the common eigenstate &#40;the output quantum state&#41; of \(\left\{Q_i(i=1,2, \cdots, n)\right\}\) with eigenvalue \(1\), then we have:</p>
\[
\begin{aligned}
& \left\langle\phi\left|\sigma_{a_1}^z\right| \phi\right\rangle=\left\langle\phi\left|\sigma_{a_1}^z Q_k\right| \phi\right\rangle \\
& \left(|\phi\rangle \text { is
 the eigenstate of } Q_k \text { with eigenvalue } 1\right.  \\
& =\left\langle\phi\left|-Q_k \sigma_{a_1}^z\right| \phi\right\rangle \quad\left(Q_k \text { anticommutes with } \sigma_{a_1}^z \right) \\
& =\left\langle\phi\left|-\sigma_{a_1}^z\right| \phi\right\rangle \quad\left(Q_k=Q_k^{\dagger}\right) \\
& =0
\end{aligned}
\]
<p>Therefore, the probability of measuring qubit \(a_1\) and obtaining the quantum state \(|0\rangle\) is:</p>
\[
\mathbb{P}_1(0)=\langle\phi \mid 0\rangle_{a_1}\langle 0 \mid \phi\rangle=\left\langle\phi\left|\frac{I+\sigma_{a_1}^z}{2}\right| \phi\right\rangle=\frac{1}{2}+\left\langle\phi\left|\sigma_{a_1}^z\right| \phi\right\rangle=\frac{1}{2}
\]
<p>After measuring qubit \(a_1\) along the \(\sigma^z\) direction, suppose it is in the quantum state \(|0\rangle\) and in a tensor product state with the other qubits. The quantum state of the system at this time is denoted as \(\left|\phi^1\right\rangle=|0\rangle_{a_1}\langle 0 \mid \phi\rangle\) &#40;not normalized&#41;.</p>
<p>Based on the operators \(\left\{Q_i\right\}\), a new set of operators \(Q_i^1(k=1,2, \cdots, n)\) is defined such that the quantum state \(\left|\phi^1\right\rangle\) after measurement is the common eigenstate with eigenvalue 1. To achieve this, construct the set \(\left\{Q_i^1\right\}\) as follows:</p>
<ul>
<li><p>Choose any operator \(Q_k\) from \(\mathcal{S}_1\) &#40;its ordering index in the set of operators \(\left\{Q_i\right\}\) is denoted as \(k\)&#41;, then the corresponding operator with the same ordering index in the set \(\left\{Q_i^1\right\}\) is defined as \(Q_k^1=\sigma_{a_1}^z\);</p>
</li>
<li><p>For the operator \(Q_{l \neq k} \in \mathcal{S}_1\), the corresponding operator in \(\left\{Q_i^1\right\}\) &#40;with ordering index 1&#41; is constructed as \(Q_l^1=\) \(Q_k Q_l\);</p>
</li>
<li><p>For the operator \(Q_i \in \mathcal{S}_2\), the corresponding operator in \(\left\{Q_i^1\right\}\) is defined as \(Q_i^1=Q_i\) &#40;with ordering index \(i\)&#41;.</p>
</li>
</ul>
<p>This results in \(n\) mutually independent operators \(\left\{Q_i^1 \mid i=1,2, \cdots, n\right\}\). Direct calculation shows that the measured quantum state \(\left|\phi^1\right\rangle\) is indeed the common eigenstate of these operators, with eigenvalue 1.</p>
<p>&#40;2&#41; Repeat the previous steps and continue to investigate the anti-commutation relations between \(\sigma_1^z, \cdots, \sigma_n^z\) and operators in \(\left\{Q_i^1\right\}\). Find the first \(\sigma_{a_2}^z\) that anti-commutes with certain operators in \(\left\{Q_i^1\right\}\). Measure the quantum bit numbered \(a_2\) and the probability of obtaining \(|0\rangle\) is still \(\frac{1}{2}\). Let the post-measurement quantum state be \(\left|\phi^2\right\rangle=|0\rangle_{a_2}\left\langle 0 \mid \phi^1\right\rangle\). Use the same method to construct operators \(Q_k^2(k=1,2, \cdots, n)\) such that \(\left|\phi^2\right\rangle\) is a common eigenstate with eigenvalue 1 for these operators.</p>
<p>&#40;3&#41; Repeat this operation \(m\) times until every \(\left\{Q_i^m \mid i=1,2, \cdots, n\right\}\). Specifically, the Pauli operators \(\sigma_{a_i}^z(i=1,2, \cdots, m)\) measured on the qubits are all included in the operator set \(\left\{Q_i^m \mid i=1,2, \cdots, n\right\}\). Note that each operator in \(\left\{Q_i^m \mid i=1,2, \cdots, n\right\}\) commutes with \(\sigma_i^z\) \((i=1,2, \cdots, n)\). Therefore, they can be generated by the operators \(\sigma_i^z(i=1,2, \cdots, n)\). In other words, \(\left\{Q_i^m \mid i=1,2, \cdots, n\right\}\) generates the same group as \(\sigma_i^z(i=1,2, \cdots, n)\).</p>
<p>Following the previous construction method, the quantum state at this point, \(\left|\phi^m\right\rangle\), is a common eigenstate with eigenvalue 1 for the operators \(\left\{Q_i^m \mid i=1,2, \cdots, n\right\}\). According to stabilizer theory<sup id="fnref:14"><a href="#fndef:14" class="fnref">[8]</a></sup>, this quantum state can be expressed as the average of all elements in the stabilizer subgroup generated by the operators \(\left\{Q_i^m \mid i=1,2, \cdots, n\right\}\), i.e.</p>
\[
\rho^m=\frac{1}{2^n} \prod_j\left(I+Q_j^m\right)=\frac{1}{2^n} \prod_j\left(I \pm \sigma_j^z\right)
\]
<p>The negative sign in the above equation only appears when there are negative elements in \(\left\{Q_k^m \mid k=1,2, \cdots, n\right\}\). Once a negative sign appears, the corresponding qubit \(j\) will be projected onto the quantum state \(|1\rangle\left(\frac{I-\sigma^z}{2}\right.\), which is the projection operator \(\left.|1\rangle\langle 1|\right)\).Therefore, the probability of measuring the state \(\left|0^n\right\rangle\) is given by:</p>
\[
\mathbb{P}\left(\left|0^n\right\rangle\right)= \begin{cases}\frac{1}{2^m}, & Q_i^m(i=1,2, \cdots, n) \text { all signs are positive, } m \text { is the number of measured qubits } \\ 0, & \text { if there exists an operator } Q_p^m \text { with a negative sign }\end{cases}
\]
<p>Classical computation only requires the calculation of all \(Q_i^m\) following the above procedure, and its computational complexity can be estimated as follows:  Establish the initial operators \(Q_i\). Since the unitary transformation \(U\) is composed only of Clifford operators, without loss of generality, \(U\) is composed of the Clifford operators \(S, H\), and CNOT. Establish the transformation table of these 3 operators with all two-qubit Pauli operators, and the initial operators \(\left\{Q_i\right\}\) &#40;all of which are Pauli operators&#41; can be established by querying this table. The complexity of this process is at most \(n \cdot n_c\), where \(n_c\) is the number of Clifford gates.</p>
<p>Update the operators \(\left\{Q_k^i\right\}\) one by one until the operator \(Q_k^m\) is obtained. At most, performing the multiplication of Pauli matrices requires \(n+(n-1)+\cdots+2+1=\mathcal{O}\left(n^2\right)\) operations. Therefore, the entire process can be effectively simulated by a classical computer.</p>
<h1 id="reference"><a href="#reference" class="header-anchor">Reference</a></h1>
<p><table class="fndef" id="fndef:1">
    <tr>
        <td class="fndef-backref"><a href="#fnref:1">[1]</a></td>
        <td class="fndef-content">Margolus, N., 1984. Physics-like models of computation. Physica D: Nonlinear Phenomena 10, 81–95.https://doi.org/10.1016/0167-2789&#40;84&#41;90252-5</td>
    </tr>
</table>
<table class="fndef" id="fndef:2">
    <tr>
        <td class="fndef-backref"><a href="#fnref:2">[2]</a></td>
        <td class="fndef-content">https://arxiv.org/abs/0907.3827, P. Arrighi and J. Grattage, “Intrinsically universal n-dimensional quantum cellular automata.”</td>
    </tr>
</table>
<table class="fndef" id="fndef:3">
    <tr>
        <td class="fndef-backref"><a href="#fnref:3">[6]</a></td>
        <td class="fndef-content">M. A. Nielsen, I. Chuang, and L. K. Grover, “Quantum computation and quantum information,” in American journal of physics, vol. 70, 2002, pp. 558–559. doi: 10.1119/1.1463744.</td>
    </tr>
</table>
<table class="fndef" id="fndef:4">
    <tr>
        <td class="fndef-backref"><a href="#fnref:4">[3]</a></td>
        <td class="fndef-content">T. M. Wintermantel, Y. Wang, G. Lochead, S. Shevate, G. K. Brennen, and S. Whitlock, “Unitary and Nonunitary Quantum Cellular Automata with Rydberg Arrays,” Phys. Rev. Lett., vol. 124, no. 7, p. 070503, Feb. 2020, doi: 10.1103/PhysRevLett.124.070503.</td>
    </tr>
</table>
<table class="fndef" id="fndef:5">
    <tr>
        <td class="fndef-backref"><a href="#fnref:5">[4]</a></td>
        <td class="fndef-content">https://www.sciencedirect.com/science/article/pii/S0010465512003955?via&#37;3Dihub J. R. Johansson, P. D. Nation, and F. Nori: &quot;QuTiP 2: A Python framework for the dynamics of open quantum systems.&quot;, Comp. Phys. Comm. 184, 1234 &#40;2013&#41; </td>
    </tr>
</table>
<table class="fndef" id="fndef:6">
    <tr>
        <td class="fndef-backref"><a href="#fnref:6">[5]</a></td>
        <td class="fndef-content">P. Arrighi and J. Grattage, “Intrinsically universal n-dimensional quantum cellular automata.” arXiv, Oct. 13, 2010. doi: 10.48550/arXiv.0907.3827.</td>
    </tr>
</table>
<a href="#footnote-7" class="footnote">[7]</a>:https://zhuanlan.zhihu.com/p/539165910 <a href="#footnote-8" class="footnote">[8]</a>:http://theory.caltech.edu/~preskill/ph219/chap5_15.pdf <a href="#footnote-9" class="footnote">[9]</a>:https://link.springer.com/content/pdf/10.1007/978-3-319-11080-6.pdf <a href="#footnote-10" class="footnote">[10]</a>:http://home.lu.lv/~sd20008/papers/essays/Clifford&#37;20group&#37;20&#91;presentation&#93;.pdf <table class="fndef" id="fndef:11">
    <tr>
        <td class="fndef-backref"><a href="#fnref:11">[12]</a></td>
        <td class="fndef-content">&#40;https://almuhammadi.com/sultan/books<em>2020/Nielsen</em>Chuang.pdf&#41;</td>
    </tr>
</table>
<a href="#footnote-12" class="footnote">[12]</a>:量子计算导论（上册）韩永建，郭光灿 <a href="#footnote-13" class="footnote">[13]</a>:http://home.lu.lv/~sd20008/papers/essays/Clifford&#37;20group&#37;20&#91;paper&#93;.pdf <a href="#footnote-14" class="footnote">[14]</a>:https://journals.aps.org/pra/pdf/10.1103/PhysRevA.70.052328,10.1103/PhysRevA.70.052328</p>
<!-- CONTENT ENDS HERE -->
      </main>
    </div> <!-- class="container" -->


    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    

    <footer id=footer class="mt-auto text-center text-muted">
        <div class="container"> Contact: <a href="mailto:jinguoliu@hkust-gz.edu.cn">jinguoliu@hkust-gz.edu.cn</a> </div>
        <div class=container>Made with <a href=https://franklinjl.org>Franklin.jl</a> and <a href=https://julialang.org>the Julia programming language</a>.</div>
    </footer>

    <!-- FEATHER -->
    <script src="/libs/feather/feather.min.js"></script>
    <script>feather.replace()</script>

    <!-- GOOGLE ANALYTICS -->
    <script>
    window.ga = window.ga || function() {
        (ga.q = ga.q || []).push(arguments)
    };
    ga.l = +new Date;
    ga('create', 'UA-154489943-1', 'auto');
    ga('send', 'pageview');
    </script>
    <script async src=https://www.google-analytics.com/analytics.js></script>
    <script src="/libs/lunr/lunr.min.js"></script>

  </body>
</html>
